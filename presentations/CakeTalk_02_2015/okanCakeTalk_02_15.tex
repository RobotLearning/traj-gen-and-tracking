%\documentclass{beamer}
\documentclass[handout]{beamer}
\usetheme{boxes} 
%\usetheme{default}

%math fonts
%\renewcommand\mathfamilydefault{\rmdefault}
\usepackage{graphicx}

%page numbers
\setbeamertemplate{footline}[page number]

\setbeamercovered{invisible}
\setbeamertemplate{navigation symbols}{} 
\usepackage{mathtools}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{epstopdf}
\usepackage{pgfplots}
\usepackage{color}
\usepackage{subfig}
\usepackage{tikzscale}
\usepackage{hyperref}
\usepackage{multimedia}
\usetikzlibrary{plotmarks}

\title[Trajectory Tracking]{Optimizing Robot Striking Movement Primitives with Iterative Learning Control}
\author{Okan Ko\c c, Guilherme Maeda, Gerhard Neumann, Jan Peters}
\institute[IAS]
{
MPI for Intelligent Systems, T\"ubingen \\
Robot Learning Lab \\
\medskip
{\emph{okan.koc@tuebingen.mpg.de}}
}
\date{\today}

% custom commands
\newcommand{\boldvec}[1]{\boldsymbol{\mathrm{#1}}}
\let\vec\boldvec
\newcommand\at[2]{\left.#1\right|_{#2}} % the at differential sign
\newcommand\scalemath[2]{\scalebox{#1}{\mbox{\ensuremath{\displaystyle #2}}}} % scaling matrices

%% custom macros
\newcommand{\todo}{\textcolor{red}{TODO}} % TODO!
\newcommand{\kin}{\mathcal{T}} % used to denote inverse kinematics
\newcommand{\invKin}{\mathcal{T}^{-1}} % used to denote inverse kinematics

\newcommand{\joint}{\vec{q}} % used to denote robot state in joint space
\newcommand{\state}{\vec{x}} % denotes the generalized coordinates - joint space and velocity coordinates
\newcommand{\dmp}{\vec{s}} % used to denote the dmp trajectory states
\newcommand{\error}{\vec{e}} % difference between state and reference
\newcommand{\traj}{\vec{r}} % used to denote the points on the trajectory to be tracked

\newcommand{\dist}{\vec{\epsilon}} % denotes the disturbances acting on the rigid body dynamics
\newcommand{\linDist}{\vec{d}} % denotes the disturbances on the LTV model

\newcommand{\sysInput}{\vec{u}} % used to denote the system inputs
\newcommand{\linInput}{\tilde{\sysInput}} % denotes the LTV inputs
\newcommand{\trjInput}{\sysInput_{\mathrm{IDM}}} % denotes the inputs on the trajectory (calculated using IDM)


% % % % DMP terminology % % % %
\newcommand{\fullvec}{\vec{\psi}} % full vector for state-ref-dmp-goal
\newcommand{\goal}{\vec{g}} % goal state
\newcommand{\force}{\vec{f}} % forcing term of the dmps
\newcommand{\phase}{x} % phase of the dmp
\newcommand{\weights}{\vec{w}} % weights of the dmp
\newcommand{\basis}{\vec{\Phi}} % basis functions of the dmp as a matrix

% % % % ILC terminology % % % %
\newcommand{\qmatrix}{\vec{\Gamma}} % denotes the filtering qmatrix term of Bristow et al.
\newcommand{\lmatrix}{\vec{L}} % denotes the learning matrix of Bristow et al.

\newcommand{\dynamics}{\vec{f}}
\newcommand{\dynamicsNominal}{\dynamics_{\mathrm{nom}}}
\newcommand{\policy}{\vec{\pi}}
\newcommand{\ValueFunction}{J}
\newcommand{\episode}{k} % used for episode number

\newcommand{\totalTime}{T} % total time duration 
\newcommand{\numSteps}{N} % total number of time steps
\newcommand{\numepisode}{K} % total number of episodes

\newcommand{\threshold}{\epsilon}
\newcommand{\alg}{\emph{wILC }}
\newcommand{\dataset}{E}

% Set the paths where all figures are taken from:
\graphicspath{{Pictures/}}
\mathtoolsset{showonlyrefs} 
\newcommand{\includesvg}[1]{%
% \executeiffilenewer{#1.svg}{#1.pdf}%
% {inkscape -z -D --file=#1.svg %
% --export-pdf=#1.pdf --export-latex}%
 \input{#1.pdf_tex}%
}
\AtBeginSection{\frame{\sectionpage}}

\begin{document}
%
\begin{frame}
\titlepage
\end{frame}
%
\begin{frame}
\frametitle{Table of Contents}
\tableofcontents
\end{frame}
%
\section{Motivation: Imitation Learning}
%
\begin{frame}{Setup}
\begin{itemize}
\item In order to hit the ball to a desired region on the opponent's court, we give the robot reference trajectories that facilitate the right striking motion. We can teach the robot such trajectories via kinesthetic teach-in.
\end{itemize}
\begin{figure}[b!]
\center
\includegraphics[scale=0.4]{robot1.png}			
\label{robot}
\caption{Ballgun faces his deadly opponent!}
\end{figure}
\end{frame}
%
\begin{frame}{Imitation Learning}
\begin{itemize}
\item Video: Demonstrations
\end{itemize}
\begin{figure}[b!]
\centering
\movie[externalviewer]{\includegraphics[scale=0.4]{robot1.png}}{okanTeachIN.MOV}
\label{Kinesthetic teach-in}
\caption{Ballgun throws the balls to approximately the same position.}
\end{figure}
\end{frame}
%
\begin{frame}{Imitation Learning}
\begin{itemize}
\item Video: Demonstrations in slow motion
\end{itemize}
\begin{figure}[b!]
\centering
\movie[externalviewer]{\includegraphics[scale=0.4]{robot1.png}}{okanTeachINSlowMotion.MOV}
\label{Slow teach-in}
\caption{In slow motion we can see better how the joints are being moved.}
\end{figure}
\end{frame}
%
\section{Movement Primitives}
%
\begin{frame}{Movement Primitives}
\begin{itemize}
\item Dynamic Movement Primitives (DMP) are a dynamical systems based approach to represent reaching motions
\begin{equation}
\begin{aligned}
\dot{\dmp} &= \vec{A}_s \dmp + \basis(\phase) \weights, \\
\dot{\phase} &= -\tau\alpha\phase.
\label{dmp1}
\end{aligned}
\end{equation}
\item As phase $\phase$ decays, the state $\dmp$ is attracted to the goal state $\goal$ and follows a particular path along the way.
\end{itemize}
\begin{figure}
\center
\includegraphics[scale=0.20]{dmp0.pdf}			
\caption{DMP following a certain path.}
\end{figure}
\end{frame}
%
\begin{frame}{Movement Primitives}
\begin{itemize}
\item DMPs are very useful for representing trajectories taught with imitation learning! 
\item One can do regression of example trajectories on the primitive weights $\weights$.
\end{itemize}
\begin{figure}
\center
\includegraphics[scale=0.25]{dmp1.pdf}			
\caption{DMP out of a trajectory.}
\end{figure}
\end{frame}
%
\begin{frame}{Nice properties of Movement Primitives}
\begin{figure}[ht]
\centering
\subfloat[Starting from a different initial position]{%
\includegraphics[width=0.5\linewidth]{dmp2.pdf}}
\subfloat[Stretching a DMP to a different goal position]{%
\includegraphics[width=0.5\linewidth]{dmp3.pdf}}
\caption{DMPs are nice!} 
\label{niceDMPs} 
\end{figure}
\end{frame}
%
\begin{frame}{Movement Primitives}
\begin{itemize}
\item Approximation and control errors in table tennis make the application of DMPs less useful in practice. Small changes to DMPs can often make them more useful.
\end{itemize}
\begin{figure}
\centering
\def\svgwidth{150pt}
\input{Pictures/ball_trj.pdf_tex}
\caption{Robot may not follow the desired DMP due to modelling errors.}
\end{figure}
\end{frame}
%
\begin{frame}{Research Question}
\begin{itemize}
\item How can we execute optimally hitting movement primitives either in table tennis or a similar reaching task e.g., putting in golf. 
%
\item More specifically, when we have modelling inaccuracies, how should we modify a DMP $\dmp(t)$ such that the robot executes a desired hitting motion?
\end{itemize}
\end{frame}
%
\begin{frame}{Remark on notation}
\begin{itemize}
\item $k$ denotes the iteration index.
\item $j$ denotes the discretization index.
\item $\sysInput_k = \begin{bmatrix} \sysInput_1 \\ \vdots \\ \sysInput_j \\ \vdots \\ \sysInput_T \end{bmatrix}$ is inputs stacked  together to form a \emph{lifted vector}.
\end{itemize}
\end{frame}
%
\section{Optimizing Movement Primitives}
%
\begin{frame}{Iterative Learning Control (ILC)}
\begin{itemize}
\item Task: track a reference trajectory $\traj(t), \ 0 \leq t \leq T \ $ under unknown repeating disturbances or model mismatch.
\item Feedforward control inputs $\sysInput(t)$ are adjusted after each iteration. The goal is drive the deviations from the trajectory to zero. 
\end{itemize}
\begin{figure}
\center
\includegraphics[scale=0.25]{ilc_framework}			
\caption{ILC Framework}
\end{figure}
\end{frame}
%
\begin{frame}{Iterative Learning Control (ILC)}
\begin{itemize}
\item A very simple update rule is to use the error $\error_k = \state_k - \traj$ and its derivatives. For example:
\begin{equation*}
\begin{aligned}
\sysInput_{k+1} = \sysInput_{k} + K_{p}\error_k + K_{d}\dot{\error}_k
\end{aligned}
\end{equation*}
\item It can easily lead to unstability! Model based update laws can be much more effective in practice!
\end{itemize}
\begin{figure}
\center
\includegraphics[scale=0.15]{ilcBlowup.pdf}			
\caption{Naive ILC Implementation}
\end{figure}
\end{frame}
%
\begin{frame}{Model-based ILC}
\begin{itemize}
\item For a linear system $\state_{j+1} = \boldvec{A}_j\state_j + \boldvec{B}_j\sysInput_j$,
\item Construct $\vec{F}$ using the model matrices $\vec{A}_j$, $\vec{B}_j$
\item $\vec{F}$ is the plant dynamics in the \emph{lifted} domain: $\state_k = \vec{F}\sysInput_k + \linDist_k$
\end{itemize}
\begin{figure}
\centering
\def\svgwidth{250pt}
\input{Pictures/plant.pdf_tex}
\caption{$\vec{F}$ is an approximation to the unknown $\vec{P}$.}
\end{figure}
\end{frame}
%
\begin{frame}{Model-based ILC}
\begin{itemize}
\item Define the cost functional
\begin{equation}
\begin{aligned}
\ValueFunction &= \sum_{j=1}^{T} \error_j^{\mathrm{T}}\vec{Q}\error_j + \sysInput_j^{\mathrm{T}}\vec{R}\sysInput_j \\ 
&:= \error_k^{\mathrm{T}}\vec{Q}_L\error_k + \sysInput_k^{\mathrm{T}}\vec{R}_L\sysInput_k
\end{aligned}
\end{equation}
\item Apply Newton's method
\end{itemize}
\begin{equation*}
\begin{aligned}
\sysInput_{k+1} &= \sysInput_{k} - \lmatrix\error_{k} \\
\lmatrix &= (\vec{F}^{\mathrm{T}}\vec{Q}_L\vec{F} + \vec{R})^{-1}\vec{F}^{\mathrm{T}}\vec{Q}_L
\end{aligned}
\end{equation*}
\end{frame}
%
\begin{frame}{Model-based ILC}
\begin{equation*}
\begin{aligned}
\sysInput_{k+1} &= \sysInput_{k} - \lmatrix\error_{k}
\end{aligned}
\end{equation*}
\begin{itemize}
\item Upper diagonal entries of $\lmatrix$ use the model matrices to predict and compensate for the \emph{future} errors on the trajectory. 
\item How do we update movement primitives?
\end{itemize}
\begin{equation}
\begin{aligned}
\dot{\dmp} &= \vec{A}_s \dmp + \basis(\phase) \weights \\
\label{dmp2}
\end{aligned}
\end{equation}
\end{frame}
%
\begin{frame}{ILC with Movement Primitives}
\begin{itemize}
\item For a system with existing feedback $\vec{K}$,
\item We can update the DMP weights $\weights_k$ 
\end{itemize}
\begin{equation*}
\begin{aligned}
\weights_{k+1} &= \weights_{k} - \lmatrix\error_{k} \\
\lmatrix &= (\vec{F}_{w}^{\mathrm{T}}\vec{Q}_L\vec{F}_w + \vec{R})^{-1}\vec{F}_w^{\mathrm{T}}\vec{Q}_L \\
\end{aligned}
\end{equation*}
\begin{figure}
\centering
\def\svgwidth{200pt}
\input{Pictures/fb_plant.pdf_tex}
\caption{Input to the feedback coupled system $\vec{P}$ is now $\dmp(t)$.}
\end{figure}
\end{frame}
%
\begin{frame}{ILC with Movement Primitives}
\begin{itemize}
\item $\vec{F}_w$ looks slightly uglier
\end{itemize}
\begin{equation*}
\begin{aligned}
\vec{F}_{w} &= \tilde{\vec{F}}_{w}\vec{F}_{\dmp}\vec{I}_{Nm \times m} \\
(\tilde{\vec{F}}_{w})_{(i,j)} &= \left \{
\begin{array}{cc}
\bar{\vec{A}}_{i}\ldots \bar{\vec{A}}_{j+1}\vec{B}_{j}\vec{K}_{j}, & j < i, \\ 
\vec{B}_{j}\vec{K}_{j}, & j = i, \\
\vec{0}, & j > i,  
\end{array} \right. \\
(\vec{F}_{s})_{(i,j)} &= \left \{
\begin{array}{cc}
\vec{A}_s^{i-1}\basis_{j}, & j < i, \\ 
\basis_{j}, & j = i, \\
\vec{0}, & j > i,  
\end{array} \right. \\
\bar{\vec{A}}_j &= \vec{A}_j - \vec{B}_j\vec{K}_j. \\
\vec{I}_{m\times Nm} &= \begin{bmatrix}
  \vec{I}_{m} & \vec{I}_{m} & \ldots & \vec{I}_{m}
 \end{bmatrix}
\end{aligned}
\end{equation*}

\end{frame}
%
\section{Application to Robotics}
%
\begin{frame}{Learning to Control Robots}
\begin{itemize}
\item Start with the Newton's laws of physics:
\begin{equation*}
\begin{aligned}
F_{net} &= ma
\end{aligned}
\end{equation*}
\item To come up with an \emph{approximate} inverse dynamics model:
\end{itemize}
\begin{equation*}
\begin{aligned}
M(\joint)\ddot{\joint} + C(\joint,\dot{\joint})\dot{\joint} + G(\joint) = \tau \\
\sysInput_{IDM} = \vec{f}_{inv}(\joint,\dot{\joint},\ddot{\joint})
\end{aligned}
\end{equation*}
\end{frame}
%
\begin{frame}{What do we need to apply ILC?}
\begin{itemize}
\item Invert to obtain the dynamics model
\end{itemize}
\begin{equation*}
\begin{aligned}
\ddot{\joint} &= M^{-1}(\joint)\{ \tau - C(\joint,\dot{\joint})\dot{\joint} - G(\joint) \}\\
\ddot{\joint} &= \vec{f}(\joint,\dot{\joint},\sysInput)
\end{aligned}
\end{equation*}
\begin{itemize}
\item Use the existing feedback on the robot
\begin{equation*}
\begin{aligned}
\sysInput_{FB} &= -\vec{K}_{p}(\joint - \joint_{des}) - \vec{K}_{d}(\dot{\joint} - \dot{\joint}_{des})
\end{aligned}
\end{equation*}
\item Linearize the dynamics around the reference trajectory $\traj(t) = [\joint_{des}, \dot{\joint}_{des}]$ to obtain $\lmatrix$. Now we can apply ILC to the movement primitives!
\end{itemize}
\begin{equation*}
\begin{aligned}
\weights_{k+1} &= \weights_{k} - \lmatrix\error_{k}
\end{aligned}
\end{equation*}
\end{frame}
%
\begin{frame}{Toy Example: Putting}
\begin{figure}[b!]
\centering
\includegraphics[scale=0.4]{putting.jpg}			
\label{putting}
\caption{You need to give the right velocity to the ball!}
\end{figure}
\end{frame}
%
\begin{frame}{Toy Example: Putting}
\begin{itemize}
\item Task: follow a pre-assigned trajectory (blue dashed curve) to give the golf ball the right velocity at impact.
\end{itemize}
\begin{figure}[ht]
\centering
\subfloat[Initial attempt]{%
\includegraphics[width=0.3\linewidth]{putting0.pdf}
\label{fig:subfig1}}
\subfloat[Final trajectory]{%
\includegraphics[width=0.3\linewidth]{putting1.pdf}
\label{fig:subfig2}}
\caption{The initial attempt falls short of the reference trajectory. We then modify the weights of the DMP to compensate for the modeling errors. The ball will then approach the hole, shown as a thick blue line at a distance of 0.5 meters, with approximately zero velocity.} 
\label{putting1} 
\end{figure}
\end{frame}
%
\begin{frame}{Toy Example: Putting}
\begin{figure}
\centering
%\includegraphics[scale=0.50]{comparison.eps}
\newlength\figureheight 
\newlength\figurewidth 
\setlength\figureheight{6cm}  
\setlength\figurewidth{6cm} 
\scalebox{0.8}{\input{Pictures/wILC.tikz}}
\caption{Convergence is quadratic for the simulated scenario where we have unknown inertial disturbances acting on the motors.}
\label{wILCTrajectoryPutting}
\end{figure}
\end{frame}
%
\begin{frame}{Recent Developments in the Primitive Sciences}
\begin{itemize}
\item Or how to optimally move your primitives!
\item Notice: no matter what weights you choose for $\dmp$, $\dot{\dmp} = \vec{A}_s \dmp + \basis(\phase) \weights$ ensures that you end up at the goal position $\goal$.
\item We don't need to depend on $\traj(t)$ to get to $\goal$: redefining $\error(t) = \state(t) - \dmp_{out}(t)$, we can optimize $\error_k^{\mathrm{T}}\vec{Q}_L\error_k + \weights_k^{\mathrm{T}}\vec{R}_L\weights_k$.
\end{itemize}
\begin{figure}
\centering
\def\svgwidth{150pt}
\input{Pictures/fb_plant_ilc.pdf_tex}
\caption{ILC that modifies also the reference trajectory $\dmp_{out}$.}
\end{figure}
\end{frame}
%
\begin{frame}{Move Your Primitives}
\begin{itemize}
\item ILC update becomes
\end{itemize}
\begin{equation*}
\begin{aligned}
$\weights_{k+1} &= \begin{bmatrix} \weights_{in} \\ \weights_{out} \end{bmatrix} \\
\weights_{k+1} &= \weights_{k} - \lmatrix_k\error_{k} \\
\lmatrix_k &= (\vec{M}_{k}^{\mathrm{T}}\vec{Q}_L\vec{M}_k + \vec{R})^{-1}\vec{M}_k^{\mathrm{T}}\vec{Q}_L \\
\vec{M}_k &= \begin{bmatrix} \vec{F}_{w,k} \\ -\vec{F}_{s} \end{bmatrix}
\end{aligned}
\end{equation*}
\end{frame}
%
\begin{frame}{Future Work}
\begin{itemize}
\item Extensions to the \alg setting: 
\begin{enumerate}
\item Trajectory states are fixed/varying $\checkmark$
\item Time profile is fixed
\item Goal states are fixed
\item Penalty matrices $\vec{Q},\vec{R}$ are fixed
\end{enumerate}
\item For table tennis one needs to consider robust control: ball trajectories may not be well estimated, ball dynamics can be quite wild!
\end{itemize}
\end{frame}
%
\begin{frame}{The End}
\begin{itemize}
\item Thank you for listening!
\end{itemize}
\end{frame}
%
% End of slides
%
\begin{frame}{Appendix A: Model-based ILC}
\begin{itemize}
\item Using the cost functional as our optimality criterion
\begin{equation}
\begin{aligned}
\ValueFunction &= \sum_{j=1}^{T} \error_j^{\mathrm{T}}\vec{Q}\error_j + \sysInput_j^{\mathrm{T}}\vec{R}\sysInput_j = \error_k^{\mathrm{T}}\vec{Q}_L\error_k + \sysInput_k^{\mathrm{T}}\vec{R}_L\sysInput_k
\end{aligned}
\end{equation}
\item With gradient descent we get: 
\end{itemize}
\begin{equation*}
\begin{aligned}
\qmatrix &= \vec{I} - \beta_k \vec{R}_L \\
\lmatrix &= \vec{F}^{\mathrm{T}}\vec{Q}_L \\
\vec{F}_{(i,j)} &= \left \{
\begin{array}{cc}
\vec{A}_{i-1}\ldots \vec{A}_j\vec{B}_{j-1}, & j < i \\ 
\vec{B}_{j-1}, & j = i \\
\vec{0}, & j > i 
\end{array} \right.
\end{aligned}
\end{equation*}
\end{frame}
%
\begin{frame}{Appendix B: Linearize around reference}
\begin{itemize}
\item Linearize the dynamics around the reference trajectory to obtain the time varying matrices $\vec{A}(t), \vec{B}(t)$
\end{itemize}
\begin{equation*}
\begin{aligned}
\dot{\error} &= \vec{A}(t)\error(t) + \vec{B}(t)\sysInput(t) + \linDist(t)\\
\end{aligned}
\end{equation*} 
\begin{itemize}
\item The time variant matrices are discretizations of 
\end{itemize}
\begin{equation*}
\begin{aligned}
\vec{A}(t) & = \at{\frac{\partial{\mathbf{f}}}{\partial{\state}}}{(\traj(t),\sysInput_{IDM}(t))} \\
\vec{B}(t) & = \at{\frac{\partial{\mathbf{f}}}{\partial{\sysInput}}}{(\traj(t),\sysInput_{IDM}(t))} \\
\end{aligned}
\end{equation*}
\begin{itemize}
\item We discretize these matrices to construct the learning matrix $L$! 
\end{itemize}
\end{frame}
%
\begin{frame}{Appendix C: Discretize linearized model}
\begin{itemize}
\item For j $\in \{ 1, 2, \ldots, T \}$, 
\end{itemize}
\begin{equation*}
\begin{aligned}
\error_{j+1} &= \vec{A}_j\error_j + \vec{B}_j\sysInput_j \\
\end{aligned}
\end{equation*}
\begin{itemize}
\item The discretized matrices can be found using: 
\linebreak
\end{itemize}
\begin{equation*}
\begin{aligned}
\exp^{h
\left[
\scalemath{0.5}{
\begin{array}{c|c}
A(jh) & B(jh) \\ \hline
0 & 0
\end{array}}\right]}
&= 
\left[
\begin{array}{c|c}
\vec{A}_j & \vec{B}_j \\ \hline
0 & I
\end{array}\right]
\end{aligned}
\end{equation*}
\end{frame}
%
\end{document} 